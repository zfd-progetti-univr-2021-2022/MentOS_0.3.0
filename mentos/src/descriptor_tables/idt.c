///                MentOS, The Mentoring Operating system project
/// @file idt.c
/// @brief Functions which manage the Interrupt Descriptor Table (IDT).
/// @copyright (c) 2019 This file is distributed under the MIT License.
/// See LICENSE.md for details.

#include "idt.h"
#include "gdt.h"
#include "debug.h"

/// @brief This function is in idt.asm.
extern void idt_flush(uint32_t idt_pointer);

/// The IDT itself.
static idt_descriptor_t idt_table[IDT_SIZE];

/// Pointer structure to give to the CPU.
idt_pointer_t idt_pointer;

// 1000 0000
#define IDT_PRESENT 0x80
// 0000 0000
#define IDT_KERNEL 0x00
// 0110 0000
#define IDT_USER 0x60
// 0000 1110
#define IDT_PADDING 0x0E

void init_idt()
{
	// Prepare IDT vector.
	for (uint32_t it = 0; it < IDT_SIZE; ++it) {
		idt_table[it].offset_low = 0;
		idt_table[it].seg_selector = 0;
		idt_table[it].null_par = 0;
		idt_table[it].options = 0;
		idt_table[it].offset_high = 0;
	}

	// Just like the GDT, the IDT has a "limit" field that is set to the last
	// valid byte in the IDT, after adding in the start position (i.e. size-1).
	idt_pointer.limit = sizeof(idt_descriptor_t) * IDT_SIZE - 1;
	idt_pointer.base = (uint32_t)&idt_table;

	// Initialize ISR for CPU execptions.
	isrs_init();

	// Initialize ISR for PIC interrupts.
	irqs_init();

	// Register ISR [0-31] + 80, interrupts generated by CPU.
	// These interrupts will be initially managed by isr_handler.
	// The appropriate handler will be called by looking at the vector
	// isr_routines.
	idt_set_gate(0, INT_0, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(1, INT_1, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(2, INT_2, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(3, INT_3, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(4, INT_4, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(5, INT_5, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(6, INT_6, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(7, INT_7, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(8, INT_8, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(9, INT_9, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(10, INT_10, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(11, INT_11, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(12, INT_12, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(13, INT_13, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(14, INT_14, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(15, INT_15, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(16, INT_16, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(17, INT_17, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(18, INT_18, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(19, INT_19, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(20, INT_20, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(21, INT_21, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(22, INT_22, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(23, INT_23, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(24, INT_24, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(25, INT_25, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(26, INT_26, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(27, INT_27, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(28, INT_28, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(29, INT_29, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(30, INT_30, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(31, INT_31, IDT_PRESENT | IDT_KERNEL, 0x8);

	// Registers ISR [32-47] (irq [0-15]), interrupts generated by PIC.
	// These interrupts will be initially managed by irq_handler.
	// The appropriate handler will be called by looking at the vector
	// isr_routines.
	idt_set_gate(32, IRQ_0, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(33, IRQ_1, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(34, IRQ_2, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(35, IRQ_3, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(36, IRQ_4, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(37, IRQ_5, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(38, IRQ_6, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(39, IRQ_7, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(40, IRQ_8, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(41, IRQ_9, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(42, IRQ_10, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(43, IRQ_11, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(44, IRQ_12, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(45, IRQ_13, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(46, IRQ_14, IDT_PRESENT | IDT_KERNEL, 0x8);
	idt_set_gate(47, IRQ_15, IDT_PRESENT | IDT_KERNEL, 0x8);

	// System call!
	idt_set_gate(128, INT_80, IDT_PRESENT | IDT_USER, 0x8);

	// Points the processor's internal register to the new IDT.
	idt_flush((uint32_t)&idt_pointer);
}

void idt_set_gate(uint8_t index, interrupt_handler_t handler, uint16_t options,
		  uint8_t seg_sel)
{
	uint32_t base_prt = (uint32_t)handler;

	// Assign the base values.
	idt_table[index].offset_low = (base_prt & 0xFFFF);
	idt_table[index].offset_high = (base_prt >> 16) & 0xFFFF;

	// Set the other fields.
	idt_table[index].null_par = 0x00;
	idt_table[index].seg_selector = seg_sel;
	idt_table[index].options = options | IDT_PADDING;
}
